# 다이나믹 프로그래밍

| 번호 | 문제 | 코드 |
|:---:|:---:|:---|
| 14226 | [이모티콘](https://www.acmicpc.net/problem/14226) | [java](https://github.com/hwlee9505/Algorithm/blob/master/boj/14226.java) |

---

# 다이나믹 프로그래밍 (동적 계획법)

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘  

DP vs 분할 정복  
- 차이점:

DP: 작은 문제가 중복이 된다. 작은 문제가 여러번 나와서 여러번 나오는 문제의 정답이 모두 항상 같다. 이 점을 이용해서 각각의 작은문제를 한번씩 푸는게 다이나믹 프로그래밍  

분할정복: 큰 문제를 작은 문제로 나눠서 푸는데 작은 문제가 중복이 되지 않는다. 모든 작은 문제가 한 번씩 나온다. 그래서 그냥 나눠서 풀면 되는 것이 분할정복이다.  

# DP 속성  

- 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.  

1. Overlapping Subproblem  

작은문제 == 부분 문제 겹친다.  

2. Optimal Substructure  

최적 부분 구조  
작은 문제가 항상 같다.  

---

# 피보나치 수열

F0 = 0  
F1 = 1  
Fn = Fn-1 + Fn-2 (n >= 2)  

## Overlapping Subproblem, 작은 문제(부분 문제)가 겹친다.

- 문제: N번째 피보나치 수를 구하는 문제  
- 작은 문제: N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제  

- 문제: N-1번째 피보나치 수를 구하는 문제  
- 작은 문제: N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제  

 .
 .
 .

큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.  
문제를 작은 문제로 쪼갤 수 있다.  


## Optimal Substructure, 최적 부분 구조

문제의 정답을 작은 문제의 정답에서 구할 수 있다.  

Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.  


ex)  
서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면  
대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.  

---

# 다이나믹 프로그래밍  

- 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.  
- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.  
- 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해 놓는다.  
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.  
- 메모를 한다고 해서 영어로 Memoization이라고 한다. (cache 느낌)  

---




